
* 캡슐화
변경될 가능성이 높은 부분을 구현 / 상대적으로 안정적인 부분을 인터페이스

* 응집도
변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
응집도가 높으면, 수정이 발생할때 그 하나의 모듈만 수정하면 된다.
아닌 경우에는 여러 모듈을 다 수정해야겠지?

* 결합도 
한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도

캡슐화를 지킬 수록 응집도는 높아지고, 결합도는 낮아진다.

데이터 중심의 설계는  캡슐화 위반, 높은 결합도, 낮은 응집도 의 문제가 있다.



어떤 요구사항 변경을 수용하기 위해 하나이상의 클래스를 수정해야 하는 것은 설계의 응집도가 낮다는 증거이다.

//내생각
setter getter사용하는게 안좋은거 같다.. --> setter getter 쓰면서 그게 드러나니까?
vo를 만드는 게 데이터 중심의 설계 인것 같다....


속성을 private 으로 설정 했다고 해도 접근자와 수정자를 통해 속성을 외부로 제공하고 있다면 캡슐화를 위반하는 것이다....
코드 중복은 악의원인이다 (!!)

//내생각
getter setter를 만들어도 되긴하지만,,
vo 외부에서 .getBlahblah 같은 함수를 사용하면.. 나중에 수정할때 너무 수정할데가 많고 코드 중복이 되므로
vo 안에서 차라리 input을 받아서 처리하는 함수를 만드는게 낫다..




Q. page.126의 isDiscountable 부분이 이해가 안간다.. 
A. 캡슐화는 변할 수 있는 어떤 것이라도 감추는 것.. 그러니까 메서드 입력할때 ctrl+space 해서 파라미터 예시 나올때도 int,String,boolean이런거 직접적으로 안나오게 하는게 좋음 클래스로표현.. 


* 데이터 중심의 설계가 변경에 취약한 이유
-데이터 중심의 설계는 본질적으로 너무 이른시기에 데이터에관해 결정하도록 강요함
-데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.


